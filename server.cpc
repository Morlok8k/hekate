#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <fcntl.h>

#include "util.h"
#include "hashtable.h"
#include "parse.h"
#include "tracker_io.h"
#include "list.h"


#define SERVER_PORT 6969

#define BUF_LEGNTH 512
#define DIR_LEN 512
#define FD_MAX 1024

int numpeers = 0;
#define MAX_CONNECTED_PEERS 512

#define MAX_PEER_CREDIT (1024 * 1024)

struct peer peers[FD_MAX];

cps int
cpc_full_read(int fd, char *buf, int len)
{
    size_t pos;
    ssize_t rc;

    pos = 0;
    while(1) {
        rc = read(fd, buf + pos, len - pos);
        if(rc == 0) {
            errno = EPIPE;
            return -1;
        } else if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= len)
                break;
        }
        cpc_io_wait(fd, CPC_IO_IN);
    }

    return pos;
}

cps int
cpc_full_write(int fd, const char *buf, int len)
{
    size_t pos;
    ssize_t rc;

    pos = 0;
    while(1) {
        /* Don't io_wait the first time. */
        rc = write(fd, buf + pos, len - pos);
        if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= len)
                break;
        }
        cpc_io_wait(fd, CPC_IO_OUT);
    }

    return pos;
}

cps int
cpc_full_writev(int fd, const struct iovec *iov, int iovcnt)
{
    size_t pos, total;
    ssize_t rc;
    int i;

    if(iovcnt == 0)
        return 0;
    else if(iovcnt == 1)
        return cpc_full_write(fd, iov[0].iov_base, iov[0].iov_len);

    total = 0;
    for(i = 0; i < iovcnt; i++)
        total += iov[i].iov_len;

    pos = 0;
    while(1) {
        if(pos == 0) {
            rc = writev(fd, iov, iovcnt);
        } else {
            size_t s = 0;
            for(i = 0; i < iovcnt; i++) {
                if(pos < s + iov[i].iov_len)
                    break;
                s += iov[i].iov_len;
            }
            assert(i < iovcnt);

            if(pos == s) {
                rc = writev(fd, iov + i, iovcnt - i);
            } else {
                /* In principle, we should build a new iovec here. */
                rc = write(fd, (char*)iov[i].iov_base + (pos - s),
                           iov[i].iov_len - (pos - s));
            }
        }

        if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= total)
                break;
        }
        cpc_io_wait(fd, CPC_IO_OUT);
    }

    return pos;
}

cps int
send_message_2(int fd, int id,
               char *body1, int bodylen1,
               char *body2, int bodylen2)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    printf("%3d -> type = %d, length = %d\n", fd, id, bodylen1 + bodylen2 + 1);

    *(uint32_t*)buf = htonl(bodylen1 + bodylen2 + 1);
    buf[4] = id;

    i = 0;

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen1 > 0) {
        iov[i].iov_base = body1;
        iov[i].iov_len = bodylen1;
        i++;
    }

    if(bodylen2 > 0) {
        iov[i].iov_base = body2;
        iov[i].iov_len = bodylen2;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_message(int fd, int id, char *body, int bodylen)
{
    unsigned char buf[5];
    int rc;

    return send_message_2(fd, id, body, bodylen, NULL, 0);
}

cps int
send_bitfield(int fd, ht_torrent *t)
{
    int num_chunks = 0, length = 0;
    unsigned char *buf= NULL;
    int rc;

    num_chunks = (t->f_length - 1) / t->p_length + 1;
    length = (num_chunks - 1) / 8 + 1;

    buf = malloc(length);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    memset(buf, 0xFF, length - 1);
    if(num_chunks % 8 == 0)
        buf[length - 1] = 0xFF;
    else
        buf[length - 1] = (0xFF00 >> (num_chunks % 8)) & 0xFF;

    rc = send_message(fd, 5, buf, length);
    if(rc < 0) {
        perror("(send_bitfield)cpc_message");
        return -1;
    }

    return 1;
}

cps int
send_choke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 0, NULL, 0);
    if(rc < 0) {
        perror("(send_choke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_unchoke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 1, NULL, 0);
    if(rc < 0) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_chunk(int fd, struct chunk *chunk)
{
    int file, rc;
    unsigned char buf[8];
    void *source;
    ht_torrent *t = peers[fd].t;

    assert(peers[fd].stream_writer);

    if(chunk->length > MAX_PEER_CREDIT) {
        fprintf(stderr, "Chunk larger than max credit!\n");
        return -1;
    }

    if(peers[fd].credit < chunk->length) {
        if(numpeers <= 1 + MAX_CONNECTED_PEERS / 10) {
            /* We've got very few peers, replenish. */
            printf("%3d replenish\n", fd);
            peers[fd].credit = MAX_PEER_CREDIT;
        } else if(numpeers < MAX_CONNECTED_PEERS) {
            /* Our queue is not full yet, choke this client for a small time. */
            printf("%3d temporary choke\n", fd);
            rc = send_choke(fd);
            if(rc < 0)
                return -1;
            free_chunks(fd);
            cpc_sleep(1);
            rc = send_unchoke(fd);
            if(rc < 0)
                return -1;
            peers[fd].credit = MAX_PEER_CREDIT;
        } else {
            /* Drop this client connection, so that others get a chance. */
            printf("%3d dropping\n", fd);
            shutdown(fd, 2);
            return -1;
        }
    }

    if(!peers[fd].t->map) {
        file = open(t->path, O_RDONLY);
        if(file < 0){
            perror("(send_chunk)open");
            return -1;
        }

        peers[fd].t->map = mmap(NULL, t->f_length, PROT_READ,
                                   MAP_PRIVATE, file, 0);
        if(peers[fd].t->map == MAP_FAILED) {
            perror("(send_chunk)mmap");
            return -1;
        }
    }

    if(chunk->offset * t->p_length + chunk->begin > t->f_length) {
        fprintf(stderr, "%03d chunk beyond end of file -- dropping.\n", fd);
        return -1;
    }

    source = peers[fd].t->map;
    source += chunk->offset*t->p_length+chunk->begin;

    printf("%3d send chunk: length=%d, offset=%lld\n",
           fd, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)(buf + 0)) = htonl(chunk->offset);
    *((uint32_t *)(buf + 4)) = htonl(chunk->begin);

    if(!incore(source, chunk->length))
        /* Since we prefetch when we first get a request, this chunk should
           arrive into core soon.  Yield in order to give it a chance. */
        /* Another strategy would be to detach if the data is not in core. */
        cpc_yield;

    rc = send_message_2(fd, 7, buf, 8, source, chunk->length);
    if(rc < 0) {
        perror("(send_chunk)write");
        return -1;
    }

    peers[fd].credit -= chunk->length;
    assert(peers[fd].credit >= 0 && peers[fd].credit < MAX_PEER_CREDIT);

    return 0;
}
/* return -1 if sth wrong happend in handshake otherwise return 0 */
cps int
handshake(hashtable *ht , int fd)
{
    int rc = 0;
    const char *protocol = "\023BitTorrent protocol";
    unsigned char hash[20];
    char *res = NULL, *tmp = NULL, t[68];
    ht_torrent *torrent = NULL;

    rc = cpc_full_read(fd, t, 68);
    if(rc < 68) {
        perror("(handshake)cpc_full_read");
        return -1;
    }

    if(memcmp(t, protocol, 20) != 0) {
        fprintf(stderr, "(handshake)bad protocol.\n");
        return -1;
    }

    memcpy(hash, t + 28, 20);

    torrent = ht_get(ht, (unsigned char *)hash);
    if(!torrent) {
        fprintf(stderr, "(handshake) : cannot find the hash in the table\n");
        return -1;
    }

    peers[fd].t = torrent;
    peers[fd].credit = MAX_PEER_CREDIT;

    //so all is ok and we can say that all is ok yupiiiii!!!!
    //now lets generate the ACK response
    res = malloc(1 + 19 + 8 + 20 + 20);
    tmp = res;

    tmp[0] = 19;
    tmp ++;

    strncpy(tmp, "BitTorrent protocol", 19);
    tmp += 19;

    memset(tmp, 0, 8);
    tmp += 8;

    memcpy(tmp, torrent->info_hash, 20);
    tmp += 20;

    memcpy(tmp, peer_id, 20);
    tmp += 20;

    rc = cpc_full_write(fd, res, 68);
    if(rc < 68) {
        perror("(handshake)cannot write to fd");
        return -1;
    }

    rc = send_bitfield(fd, torrent);
    if(rc < 0) {
        fprintf(stderr, "couldn't send bitfield\n");
        return -1;
    }

    return 0;
}

cps void
stream_writer(int fd)
{
    //while request list non empty, send chunks
    struct chunk *cl;
    int rc;

    assert(peers[fd].stream_writer);

    while((cl = peers[fd].list)) {
        peers[fd].list = peers[fd].list->next;
        rc = send_chunk(fd, cl);
        free(cl);
        if(rc < 0) {
            shutdown(fd, 2);    /* for now */
            break;
        }
        cpc_yield;
    }
    peers[fd].stream_writer = 0;
    return;
}

cps int
stream_reader(int fd)
{
    uint32_t tmp = 0, length = 0;
    char * res = NULL;
    uint32_t begin, index, chunk_len;

    if(cpc_full_read(fd, &tmp, 4) < 4) {
        perror("(stream_read) didn't read 4 bytes");
        return -1;
    }

    length = ntohl(tmp);
    if(length == 0) {
        //keepalive message
        return 0;
    }

    if(length > 128 * 1024) {
        printf("%3d unbelievably long message (%d bytes).\n", fd, length);
        return -1;
    }

    res = malloc(length);
    if(res == NULL)
        return -1;

    if(cpc_full_read(fd, res, length) < 0) {
        perror("(stream_read)cpc_full_read");
        goto fail;
    }

    printf("%3d <- type = %d, length = %d\n", fd, res[0], length);

    if(res[0] != 5 && length > 20) {
        printf("%3d unbelievably long message!\n", fd);
        goto fail;
    }

    switch(res[0]) {
    case 7: case 5: case 0: case 4: case 1: case 2:
        break;

    case 3:                     //not interested
        printf("%3d not interested\n", fd);
        goto fail;

    case 6:                     //request
    case 8:                     //cancel
        if(length < 13)
            goto fail;
        index = ntohl(*((uint32_t *)(res+1)));
        begin = ntohl(*((uint32_t *)(res+5)));
        chunk_len = ntohl(*((uint32_t *)(res+9)));
        printf("%3d %s: index = %u\tbegin = %u\tlength = %u\n",
               fd, res[0] == 6 ? "request" : "cancel",
               index, begin, chunk_len);
        if(chunk_len > 1024 * 1024) {
            fprintf(stderr, "Unbelievably large chunk size requested.\n");
            goto fail;
        }

        if(res[0] == 6) {
            /* add request in request list */
            peers[fd].list = add_chunk(peers[fd].list,
                                          index, begin, chunk_len);
            if(peers[fd].t->map)
                prefetch(peers[fd].t->map +
                         index * peers[fd].t->p_length + begin,
                         chunk_len);
            if(peers[fd].stream_writer == 0) {
                peers[fd].stream_writer = 1;
                cpc_spawn stream_writer(fd);
            }
        } else {
            peers[fd].list = remove_chunk(peers[fd].list,
                                             index, begin, chunk_len);
        }
        break;

    default:
        fprintf(stderr , "%3d unexpected message.\n", fd);
        goto fail;
    }
    free(res);
    return 0;

 fail:
    free(res);
    return -1;
}

void
free_chunk_list(struct chunk* c) {
    struct chunk *next;
    while(c) {
        next = c->next;
        free(c);
        c = next;
    }
}


void
free_chunks(int fd)
{
    free_chunk_list(peers[fd].list);
    peers[fd].list = NULL;
    return ;
}

cps void
client(hashtable *t, int client_fd)
{
    int rc = 0;
    unsigned char buffer[BUF_LEGNTH];

    rc = handshake(t, client_fd);
    if(rc < 0) {
        fprintf(stderr,"(client)broken handshake -- dropping.\n");
        goto done;
    }

    rc = send_unchoke(client_fd);
    if(rc < 0) {
        fprintf(stderr, "couldn't send unchoke\n");
        return;
    }

    while(1) {
        if(stream_reader(client_fd) < 0)
            break;
    }

 done:
    if(peers[client_fd].stream_writer) {
        shutdown(client_fd, 2);
        /* XXX should use explicit signalling here. */
        do {
            cpc_yield;
        } while(peers[client_fd].stream_writer);
    }
    free_chunks(client_fd);
    peers[client_fd].t = NULL;
    numpeers--;
    close(client_fd);
    return;
}

cps void
listening(hashtable * table)
{
    int socket_fd, client_fd;
    int rc, flags, one = 1;
    socklen_t cli_len;
    struct sockaddr_in serv_addr, cli_addr;

    socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if(socket_fd<0) {
        perror("(listening)socket");
        return;
    }
    rc = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    if(rc) {
        perror("(listening)setsockopt");
        return;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(SERVER_PORT);

    if (bind(socket_fd, (struct sockaddr *) &serv_addr,
             sizeof(serv_addr)) < 0)
        perror("(listening)bind");

    memset(peers, 1024*sizeof(struct peer), 0);

    rc = listen(socket_fd, 20);
    if(rc < 0) {
        perror("(listening)listen");
        return;
    }

    while(1) {
        cli_len = sizeof(cli_addr);

        cpc_io_wait(socket_fd, CPC_IO_IN);
        client_fd = accept(socket_fd,
                           (struct sockaddr *) &cli_addr,
                           &cli_len);
        if(client_fd<0) {
            perror("(listening)accept");
            cpc_sleep(1);
            continue;
        }
        fprintf(stderr,"Got a connection!\n");
        assert(!peers[client_fd].t);

        /* XXX */
        if(client_fd > FD_MAX)
            goto fail;

        assert(numpeers >= 0 && numpeers <= MAX_CONNECTED_PEERS);
        if(numpeers >= MAX_CONNECTED_PEERS) {
            fprintf(stderr, "Dropping peer connection.\n");
            goto fail;
        }

        flags = fcntl(client_fd, F_GETFL);
        if(flags < 0) {
            perror("F_GETFL");
            goto fail;
        }
        rc = fcntl(client_fd, F_SETFL, flags|O_NONBLOCK);
        if(rc < 0) {
            perror("F_SETFL");
            goto fail;
        }

        numpeers++;
        cpc_spawn client(table, client_fd);
        continue;

    fail:
        close(client_fd);
        continue;
    }

    return;
}
