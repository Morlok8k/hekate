/*
Copyright (c) 2009 by Pejman Attar, Yoann Canal, Juliusz Chroboczek and
                      Gabriel Kerneis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <fcntl.h>

#include "util.h"
#include "hashtable.h"
#include "parse.h"
#include "tracker.h"
#include "list.h"
#include "io.h"

#define SERVER_PORT 6969

#define BUF_LENGTH 512
#define DIR_LEN 512
#define FD_MAX 1024

int numpeers = 0;
#define MAX_CONNECTED_PEERS 512

#define MAX_PEER_CREDIT (1024 * 1024)

struct peer peers[FD_MAX];

cps int
send_message_2(int fd, int id,
               char *body1, int bodylen1, char *body2, int bodylen2)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    printf("%3d -> type = %d, length = %d\n", fd, id, bodylen1 + bodylen2 + 1);

    *(uint32_t*)buf = htonl(bodylen1 + bodylen2 + 1);
    buf[4] = id;

    i = 0;

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen1 > 0) {
        iov[i].iov_base = body1;
        iov[i].iov_len = bodylen1;
        i++;
    }

    if(bodylen2 > 0) {
        iov[i].iov_base = body2;
        iov[i].iov_len = bodylen2;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_message(int fd, int id, char *body, int bodylen)
{
    return send_message_2(fd, id, body, bodylen, NULL, 0);
}

cps int
send_message_h(int fd, char *head, int headlen,
               int id, char *body, int bodylen)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    printf("%3d -> h=%d, type = %d, length = %d\n",
           fd, headlen, id, bodylen + 1);

    *(uint32_t*)buf = htonl(bodylen + 1);
    buf[4] = id;

    i = 0;

    if(headlen > 0) {
        iov[i].iov_base = head;
        iov[i].iov_len = headlen;
        i++;
    }

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen > 0) {
        iov[i].iov_base = body;
        iov[i].iov_len = bodylen;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_bitfield(int fd, ht_torrent *t, char *head, int headlen)
{
    int num_chunks = 0, length = 0;
    unsigned char *buf= NULL;
    int rc;

    length = (t->num_chunks - 1) / 8 + 1;

    buf = malloc(length);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    memset(buf, 0xFF, length - 1);
    if(num_chunks % 8 == 0)
        buf[length - 1] = 0xFF;
    else
        buf[length - 1] = (0xFF00 >> (num_chunks % 8)) & 0xFF;

    rc = send_message_h(fd, head, headlen, 5, buf, length);
    if(rc < 0) {
        perror("(send_bitfield)cpc_message");
        return -1;
    }

    return 1;
}

cps int
send_choke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 0, NULL, 0);
    if(rc < 0) {
        perror("(send_choke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_unchoke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 1, NULL, 0);
    if(rc < 0) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_multi_chunk(int fd, struct chunk *chunk, int first)
{
    unsigned char *body;
    int file, rc, i, pos;
    int64_t begin, end;
    unsigned char head[8];
    ht_torrent *t = peers[fd].t;
    struct file *f;

    printf("send_multi\n");

    begin = chunk->offset * t->p_length + chunk->begin;
    end = begin + chunk->length;

    body = malloc(chunk->length);
    if(!body) {
        perror("(send_multi_chunk)malloc");
        return -1;
    }

    i = first;
    pos = 0;
    while(pos < chunk->length) {
        f = t->files[i];
        if(!f->map) {
            file = open(f->path, O_RDONLY);
            if(file < 0){
                perror("(send_chunk)open");
                return -1;
            }

            f->map = mmap(NULL, f->length, PROT_READ,
                                    MAP_PRIVATE, file, 0);
            if(f->map == MAP_FAILED) {
                perror("(send_chunk)mmap");
                return -1;
            }
        }
        if(i == first) {
            memcpy(body + pos, f->map + begin - f->offset,
                   f->length - begin + f->offset);
            pos += f->length - begin + f->offset;
        }
        else if(pos + f->length > chunk->length) {
            memcpy(body + pos, f->map,
                   f->length - end + f->offset);
            pos += f->length - end + f->offset;
        }
        else {
            memcpy(body + pos, f->map, f->length);
            pos += f->length;
        }
        i++;
    }

    printf("%3d send chunk: length=%d, offset=%lld\n",
           fd, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)(head + 0)) = htonl(chunk->offset);
    *((uint32_t *)(head + 4)) = htonl(chunk->begin);

    rc = send_message_2(fd, 7, head, 8, body, chunk->length);
    if(rc < 0) {
        perror("(send_chunk)write");
        return -1;
    }

    peers[fd].credit -= chunk->length;
    assert(peers[fd].credit >= 0 && peers[fd].credit < MAX_PEER_CREDIT);

    return 0;
}

cps int
send_chunk(int fd, struct chunk *chunk)
{
    int file, i, rc;
    unsigned char buf[8];
    void *source;
    ht_torrent *t = peers[fd].t;
    int64_t begin, end; /* offsets */
    int first, last; /* files */
    struct file *f;

    assert(peers[fd].stream_writer);

    begin = chunk->offset * t->p_length + chunk->begin;
    end = begin + chunk->length;

    first = 0;
    last = 0;
    for(i = 0; i < t->num_files; i++) {
        f = t->files[i];
        if(f->offset < begin) {
            first = i;
        }
        if(f->offset + f->length > end) {
            last = i;
            break;
        }
    }

    if(first != last)
        return send_multi_chunk(fd, chunk, first);

    if(chunk->length > MAX_PEER_CREDIT) {
        fprintf(stderr, "Chunk larger than max credit!\n");
        return -1;
    }

    if(peers[fd].credit < chunk->length) {
        if(numpeers <= 1 + MAX_CONNECTED_PEERS / 10) {
            /* We've got very few peers, replenish. */
            printf("%3d replenish\n", fd);
            peers[fd].credit = MAX_PEER_CREDIT;
        } else if(numpeers < MAX_CONNECTED_PEERS) {
            /* Our queue is not full yet, choke this client for a small time. */
            printf("%3d temporary choke\n", fd);
            rc = send_choke(fd);
            if(rc < 0)
                return -1;
            free_chunks(fd);
            cpc_sleep(1);
            rc = send_unchoke(fd);
            if(rc < 0)
                return -1;
            peers[fd].credit = MAX_PEER_CREDIT;
        } else {
            /* Drop this client connection, so that others get a chance. */
            printf("%3d dropping\n", fd);
            shutdown(fd, 2);
            return -1;
        }
    }

    if(!peers[fd].t->files[first]->map) {
        file = open(t->files[first]->path, O_RDONLY);
        if(file < 0){
            perror("(send_chunk)open");
            return -1;
        }

        peers[fd].t->files[first]->map = mmap(NULL, t->files[first]->length, PROT_READ,
                                              MAP_PRIVATE, file, 0);
        if(peers[fd].t->files[0]->map == MAP_FAILED) {
            perror("(send_chunk)mmap");
            return -1;
        }
    }

    if(begin > t->files[first]->length) {
        fprintf(stderr, "%03d chunk beyond end of file -- dropping.\n", fd);
        return -1;
    }

    source = peers[fd].t->files[first]->map;
    source += begin - peers[fd].t->files[first]->offset;

    printf("%3d send chunk: length=%d, offset=%lld\n",
           fd, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)(buf + 0)) = htonl(chunk->offset);
    *((uint32_t *)(buf + 4)) = htonl(chunk->begin);

    if(!incore(source, chunk->length))
        /* Since we prefetch when we first get a request, this chunk should
           arrive into core soon.  Yield in order to give it a chance. */
        /* Another strategy would be to detach if the data is not in core. */
        cpc_yield;

    rc = send_message_2(fd, 7, buf, 8, source, chunk->length);
    if(rc < 0) {
        perror("(send_chunk)write");
        return -1;
    }

    peers[fd].credit -= chunk->length;
    assert(peers[fd].credit >= 0 && peers[fd].credit < MAX_PEER_CREDIT);

    return 0;
}
/* return -1 if sth wrong happend in handshake otherwise return 0 */
cps int
handshake(hashtable *ht , int fd)
{
    int rc = 0;
    const char *protocol = "\023BitTorrent protocol";
    unsigned char hash[20];
    char *res = NULL, *tmp = NULL, t[68];
    ht_torrent *torrent = NULL;

    rc = cpc_full_read(fd, t, 68);
    if(rc < 68) {
        perror("(handshake)cpc_full_read");
        return -1;
    }

    if(memcmp(t, protocol, 20) != 0) {
        fprintf(stderr, "(handshake)bad protocol.\n");
        return -1;
    }

    memcpy(hash, t + 28, 20);

    torrent = ht_get(ht, (unsigned char *)hash);
    if(!torrent) {
        fprintf(stderr, "(handshake) : cannot find the hash in the table\n");
        return -1;
    }

    peers[fd].t = torrent;
    peers[fd].credit = MAX_PEER_CREDIT;

    //so all is ok and we can say that all is ok yupiiiii!!!!
    //now lets generate the ACK response
    res = malloc(1 + 19 + 8 + 20 + 20);
    tmp = res;

    tmp[0] = 19;
    tmp ++;

    strncpy(tmp, "BitTorrent protocol", 19);
    tmp += 19;

    memset(tmp, 0, 8);
    tmp += 8;

    memcpy(tmp, torrent->info_hash, 20);
    tmp += 20;

    memcpy(tmp, peer_id, 20);
    tmp += 20;

    rc = send_bitfield(fd, torrent, res, 68);
    if(rc < 0)
        return -1;

    return 0;
}

cps void
stream_writer(int fd)
{
    //while request list non empty, send chunks
    struct chunk *cl;
    int rc;

    assert(peers[fd].stream_writer);

    while((cl = peers[fd].list)) {
        peers[fd].list = peers[fd].list->next;
        rc = send_chunk(fd, cl);
        free(cl);
        if(rc < 0) {
            shutdown(fd, 2);    /* for now */
            break;
        }
        cpc_yield;
    }
    peers[fd].stream_writer = 0;
    return;
}

cps int
stream_reader(int fd)
{
    uint32_t tmp = 0, length = 0;
    char * res = NULL;
    uint32_t begin, index, chunk_len;

    while(1){
        if(cpc_full_read(fd, &tmp, 4) < 4) {
            perror("(stream_read) didn't read 4 bytes");
            return -1;
        }

        length = ntohl(tmp);
        if(length == 0) {
            //keepalive message
            continue;
        }

        if(length > 128 * 1024) {
            printf("%3d unbelievably long message (%d bytes).\n", fd, length);
            return -1;
        }

        res = malloc(length);
        if(res == NULL)
            return -1;

        if(cpc_full_read(fd, res, length) < 0) {
            perror("(stream_read)cpc_full_read");
            goto fail;
        }

        printf("%3d <- type = %d, length = %d\n", fd, res[0], length);

        if(res[0] != 5 && length > 20) {
            printf("%3d unbelievably long message!\n", fd);
            goto fail;
        }

        switch(res[0]) {
        case 7: case 5: case 0: case 1: case 2: case 4:
            break;

        case 3:                     //not interested
            printf("%3d not interested\n", fd);
            goto fail;

        case 6:                     //request
        case 8:                     //cancel
            if(length < 13)
                goto fail;
            index = ntohl(*((uint32_t *)(res+1)));
            begin = ntohl(*((uint32_t *)(res+5)));
            chunk_len = ntohl(*((uint32_t *)(res+9)));
            printf("%3d %s: index = %u\tbegin = %u\tlength = %u\n",
                   fd, res[0] == 6 ? "request" : "cancel",
                   index, begin, chunk_len);
            if(chunk_len > 1024 * 1024) {
                fprintf(stderr, "Unbelievably large chunk size requested.\n");
                goto fail;
            }

            if(res[0] == 6) {
                /* add request in request list */
                peers[fd].list = add_chunk(peers[fd].list,
                                           index, begin, chunk_len);
                if(peers[fd].t->num_files == 1 &&
                   peers[fd].t->files[0]->map)
                    prefetch(peers[fd].t->files[0]->map +
                             index * peers[fd].t->p_length + begin,
                             chunk_len);
                if(peers[fd].stream_writer == 0) {
                    peers[fd].stream_writer = 1;
                    cpc_spawn stream_writer(fd);
                }
            } else {
                peers[fd].list = remove_chunk(peers[fd].list,
                                              index, begin, chunk_len);
            }
            break;

        default:
            fprintf(stderr , "%3d unexpected message.\n", fd);
            goto fail;
        }
        free(res);
    }
 fail:
    free(res);
    return -1;
}

void
free_chunk_list(struct chunk* c) {
    struct chunk *next;
    while(c) {
        next = c->next;
        free(c);
        c = next;
    }
}


void
free_chunks(int fd)
{
    free_chunk_list(peers[fd].list);
    peers[fd].list = NULL;
    return ;
}

cps void
client(hashtable *t, int client_fd)
{
    int rc = 0;
    unsigned char buffer[BUF_LENGTH];

    rc = handshake(t, client_fd);
    if(rc < 0) {
        fprintf(stderr,"(client)broken handshake -- dropping.\n");
        goto done;
    }

    rc = send_unchoke(client_fd);
    if(rc < 0) {
        fprintf(stderr, "couldn't send unchoke\n");
        return;
    }
    rc = stream_reader(client_fd);

 done:
    if(peers[client_fd].stream_writer) {
        shutdown(client_fd, 2);
        /* XXX should use explicit signalling here. */
        do {
            cpc_yield;
        } while(peers[client_fd].stream_writer);
    }
    free_chunks(client_fd);
    peers[client_fd].t = NULL;
    numpeers--;
    close(client_fd);
    return;
}

cps void
listening(hashtable * table)
{
    int socket_fd, client_fd;
    int rc, flags, one = 1, zero = 0;
    socklen_t cli_len;
    struct sockaddr_in6 serv_addr, cli_addr;

    socket_fd = socket(AF_INET6, SOCK_STREAM, 0);
    if(socket_fd<0) {
        perror("(listening)socket");
        return;
    }

    rc = setsockopt(socket_fd, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(zero));
    if(rc) {
        perror("(listening)setsockopt(IPV6_V6ONLY)");
        return;
    }

    rc = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    if(rc) {
        perror("(listening)setsockopt");
        return;
    }

    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin6_family = AF_INET6;
    serv_addr.sin6_port = htons(SERVER_PORT);

    if (bind(socket_fd, (struct sockaddr *) &serv_addr,
             sizeof(serv_addr)) < 0)
        perror("(listening)bind");

    memset(peers, FD_MAX*sizeof(struct peer), 0);

    rc = listen(socket_fd, 20);
    if(rc < 0) {
        perror("(listening)listen");
        return;
    }

    while(1) {
        cpc_io_wait(socket_fd, CPC_IO_IN);

        cli_len = sizeof(cli_addr);
        client_fd = accept(socket_fd,
                           (struct sockaddr *)&cli_addr,
                           &cli_len);
        if(client_fd<0) {
            perror("(listening)accept");
            cpc_sleep(1);
            continue;
        }
        fprintf(stderr,"Got a connection!\n");
        assert(!peers[client_fd].t);

        /* XXX */
        if(client_fd > FD_MAX)
            goto fail;

        assert(numpeers >= 0 && numpeers <= MAX_CONNECTED_PEERS);
        if(numpeers >= MAX_CONNECTED_PEERS) {
            fprintf(stderr, "Dropping peer connection.\n");
            goto fail;
        }

        flags = fcntl(client_fd, F_GETFL);
        if(flags < 0) {
            perror("F_GETFL");
            goto fail;
        }
        rc = fcntl(client_fd, F_SETFL, flags|O_NONBLOCK);
        if(rc < 0) {
            perror("F_SETFL");
            goto fail;
        }

        numpeers++;
        cpc_spawn client(table, client_fd);
        continue;

    fail:
        close(client_fd);
        continue;
    }

    return;
}
