#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <fcntl.h>

#include "hashtable.h"
#include "parse.h"
#include "tracker_io.h"
#include "list.h"


#define SERVER_PORT 6969

#define BUF_LEGNTH 512
#define DIR_LEN 512

/*XXX 1024 -> FD_MAX*/
flist requests[1024];

cps int
cpc_full_read(int fd, void *buf, int length)
{
    int pos, rc;

    for(pos = 0; pos < length; pos += rc) {
        cpc_io_wait(fd, CPC_IO_IN);
        rc = read(fd, buf + pos, length - pos);
        if(rc < 0 && errno != EAGAIN) return rc;
    }
    return length;
}

cps int
cpc_full_write(int fd, void *buf, int length)
{
    int pos, rc;

    for(pos = 0; pos < length; pos += rc) {
        cpc_io_wait(fd, CPC_IO_OUT);
        rc = write(fd, buf + pos, length - pos);
        if(rc < 0 && errno != EAGAIN) return rc;
    }
    return length;
}

cps int
send_bitfield(int fd, ht_torrent *t)
{
    int num_chunks = 0, length = 0;
    unsigned char *buf= NULL;

    num_chunks = (t->f_length - 1)/t->p_length + 1;
    length = (num_chunks - 1)/8 + 1;

    buf = malloc(length + 5);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    /* XXX initialise only num_chunks to 1 */
    memset(buf + 5, 0xFF, length);
    ((uint32_t *)buf)[0] = htonl(length + 1);
    buf[4] = 5;
    printf("length=%d, type=%d\n", ntohl(((uint32_t *)buf)[0]), buf[4]);

    if(cpc_full_write(fd, buf, length + 5) < 0) {
        perror("(send_bitfield)cpc_full_write");
        return -1;
    }

    return 0;
}

cps int
send_unchoke(int fd)
{
    unsigned char buf[5];

    ((uint32_t *)buf)[0] = htonl(1);
    buf[4] = 1;

    if(cpc_full_write(fd, buf, 5) < 5) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_piece(int fd, piece *chunk)
{
    int file;
    unsigned char buf[13];
    void *source;
    ht_torrent *t = requests[fd].t;

    printf("send chunk: length=%d, offset=%lld\n",
           chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)buf) = htonl(chunk->length + 9);
    buf[4] = 7;

    *((uint32_t *)(buf + 5)) = htonl(chunk->offset);
    *((uint32_t *)(buf + 9)) = htonl(chunk->begin);

    if(cpc_full_write(fd, buf, 13) < 13) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }

    if(!requests[fd].t->map) {
        file = open(t->path, O_RDONLY);
        if(file < 0){
            perror("(send_piece)open");
            return -1;
        }

        requests[fd].t->map = mmap(NULL, t->f_length, PROT_READ,
                                   MAP_PRIVATE, file, 0);
        if(requests[fd].t->map == MAP_FAILED) {
            perror("(send_piece)mmap source");
            return -1;
        }
    }

    source = requests[fd].t->map;
    source += chunk->offset*t->p_length+chunk->begin;

    if(cpc_full_write(fd, source, chunk->length)<chunk->length){
        perror("(send_piece)write");
        return -1;
    }

    return 0;
}
/*
  return 01 if sth wrong happend in
  handshake otherwise return 0
 */
cps int
handshake(hashtable *ht , int fd)
{
    int rc = 0;
    const char *protocol = "BitTorrent protocol";
    unsigned char hash[20];
    char *res = NULL, *tmp = NULL, t[68];
    ht_torrent *torrent = NULL;

    if(cpc_full_read(fd, t, 68) < 68) {
        perror("(handshake)cpc_full_read");
        return -1;
    }

    if(t[0] != 19) {
        fprintf(stderr,"(handshake)bad protocol %c\n", *t);
        return -1;
    }

    if(memcmp(t + 1, protocol, 19)) {
        perror("(handshake)memcmp");
        return -1;
    }

    if(!memcpy(hash, t + 28, 20)) {
        perror("(handshake)memcpy");
        return -1;
    }

    if (!(torrent = ht_get( ht, (unsigned char *)hash ))) {
        fprintf(stderr, "(handshake) : cannot find the hash in the table");
        return -1;
    }

    requests[fd].t = torrent;

    //so all is ok and we can say that all is ok yupiiiii!!!!
    //now lets generate the ACK response
    res = malloc(1 + 19 + 8 + 20 + 20);
    tmp = res;

    tmp[0] = 19;
    tmp ++;

    strncpy(tmp, "BitTorrent protocol", 19);
    tmp += 19;

    tmp[0] = tmp[1] = tmp[2] = tmp[3] =
        tmp[4] =tmp[5] =tmp[6] =tmp[7] = 0;
    tmp += 8;

    if(!memcpy(tmp, torrent->info_hash, 20)) {
        perror("(handshake)cannot copy the hash");
        return -1;
    }
    tmp += 20;

    strncpy(tmp, peer_id, 20);
    tmp = NULL;
    if(cpc_full_write(fd, res, 68) < 68) {
        perror("(handshake)cannot write to fd");
        return -1;
    }

    if(send_bitfield(fd, torrent)<0) {
        fprintf(stderr, "couldn't send bitfield\n");
        return -1;
    }

    if(send_unchoke(fd)<0) {
        fprintf(stderr, "couldn't send unchoke\n");
        return -1;
    }

    return 0;
}

cps void
stream_writer(int fd)
{
    //while request list non empty, send chunks
    piece *pl;

    while((pl = requests[fd].list)) {
        requests[fd].list = requests[fd].list->next;
        send_piece(fd, pl);
        free(pl);
        cpc_yield;
    }
    requests[fd].flag = 0;
    return;
}

cps int
stream_reader(int fd)
{
    uint32_t tmp = 0, length = 0;
    char * res = NULL;

    if(cpc_full_read(fd, &tmp, 4) < 4) {
        perror("(stream_read) didn't read 4 bytes");
        return -1;
    }

    length = ntohl(tmp);
    if(length == 0) {
        //keepalive message
        return 0;
    }
    //non-keepalive message
    /* beware of malloc size, should never be >12 except for bitfield */
    res = malloc(length);
    assert(res);
    if(cpc_full_read(fd, res, length) < 0) {
        perror("(stream_read)cpc_full_read");
        free(res);
        return -1;
    }

    //i am not sure that this is a good idea
    printf("message length: %d, type: %d\n", length, res[0]);
    switch(res[0]) {
    case  7 : case  5 : case 0: case 4:
        free(res);
        return 0;
    case  1 :
        //unchoke
        //no payload
        printf("unchoke\n");
        break;

    case  2 :
        //interested
        //no payload
        printf("Win : so let him dl everything he want\n");
        break;

    case  3 :
        //not interested
        printf("not interested\n");
        return -1; /* XXX */

    case  6 ://request
        printf("request: index = %d \tbegin = %d\tlength = %d\n",
               ntohl(*((int32_t *)(res+1))),
               ntohl(*((int32_t *)(res+5))),
               ntohl(*((int32_t *)(res+9))));

        /* add request in request list */
        requests[fd].list = add_piece(requests[fd].list,
                                      ntohl(*((int64_t *)(res + 1))),
                                      ntohl(*((int32_t *)(res + 5))),
                                      ntohl(*((int32_t *)(res + 9))));
        if(requests[fd].flag == 0) {
            requests[fd].flag = 1;
            cpc_spawn stream_writer(fd);
        }
        break;

    case  8 ://cancel
        printf("cancel: index = %d \tbegin = %d\tlength = %d\n",
               ntohl(*((int32_t *)(res + 1))),
               ntohl(*((int32_t *)(res + 5))),
               ntohl(*((int32_t *)(res + 9))));

        requests[fd].list = remove_piece(requests[fd].list,
                                         ntohl(*((int64_t *)(res+1))),
                                         ntohl(*((int32_t *)(res+5))),
                                         ntohl(*((int32_t *)(res+9))));

        break;

    default :
        free(res);
        fprintf(stderr , "(stream_read)Someone sending weird message\n");
        //not supported by protocol
        return -1;
    }
    free(res);
    return 0;
}

cps void
client(hashtable *t, int client_fd)
{
    int rc = 0;
    unsigned char buffer[BUF_LEGNTH];

    rc = handshake(t, client_fd);
    if(rc < 0) {
        fprintf(stderr,"(client)handshake: handshake is just like a footshake\n");
        return;
    }

    while(1)
        if(stream_reader(client_fd)<0)
            break;

    close(client_fd);
    return;
}

cps void
listening(hashtable * table)
{
    int socket_fd, client_fd;
    int rc, flags, one = 1;
    socklen_t cli_len;
    struct sockaddr_in serv_addr, cli_addr;

    socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if(socket_fd<0) {
        perror("(listening)socket");
        return;
    }
    rc = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    if(rc) {
        perror("(listening)setsockopt");
        return;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(SERVER_PORT);

    if (bind(socket_fd, (struct sockaddr *) &serv_addr,
             sizeof(serv_addr)) < 0)
        perror("(listening)bind");

    memset(requests, 1024*sizeof(piece), 0);

    while(1) {
        rc = listen(socket_fd, 20);
        if(rc) perror("(listening)listen");

        while(1) {
            cli_len = sizeof(cli_addr);

            cpc_io_wait(socket_fd, CPC_IO_IN);
            client_fd = accept(socket_fd,
                               (struct sockaddr *) &cli_addr,
                               &cli_len);
        fprintf(stderr,"Got a connection!\n");
            if(client_fd<0 && errno!=EAGAIN && errno!=EWOULDBLOCK) {
                perror("(listening)accept");
                return;
            }

            flags = fcntl(client_fd, F_GETFL);
            rc = fcntl(client_fd, F_SETFL, flags|O_NONBLOCK);
            if(flags < 0 || rc < 0) {
                perror("(listening)fcntl");
                close(client_fd);
                continue;
            }

            cpc_spawn client(table, client_fd);
        }
    }

    return;
}
