#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <fcntl.h>

#include "hashtable.h"
#include "parse.h"
#include "tracker_io.h"
#include "list.h"


#define SERVER_PORT 6969

#define BUF_LEGNTH 512
#define DIR_LEN 512
#define FD_MAX 1024

flist requests[FD_MAX];

cps int
cpc_full_read(int fd, char *buf, int len)
{
    int pos, rc;

    pos = 0;
    while(1) {
        rc = read(fd, buf + pos, len - pos);
        if(rc == 0) {
            errno = EPIPE;
            return -1;
        } else if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= len)
                break;
        }
        cpc_io_wait(fd, CPC_IO_IN);
    }

    return pos;
}

cps int
cpc_full_write(int fd, const char *buf, int len)
{
    int pos, rc;

    pos = 0;
    while(1) {
        /* Don't io_wait the first time. */
        rc = write(fd, buf + pos, len - pos);
        if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= len)
                break;
        }
        cpc_io_wait(fd, CPC_IO_OUT);
    }

    return pos;
}

cps int
cpc_full_write_2(int fd,
                 const char *buf1, int len1, const char *buf2, int len2)
{
    struct iovec iov[2];
    int pos, rc;

    if(len2 == 0)
        return cpc_full_write(fd, buf1, len1);

    iov[0].iov_base = buf1;
    iov[0].iov_len = len1;

    iov[1].iov_base = buf2;
    iov[1].iov_len = len2;

    pos = 0;
    while(1) {
        rc = writev(fd, iov, 2);
        if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= len1)
                break;
        }
        cpc_io_wait(fd, CPC_IO_OUT);
    }

    if(pos < len1 + len2) {
        cpc_io_wait(fd, CPC_IO_OUT);
        rc = cpc_full_write(fd, buf2 + (pos - len1), len2 - (pos - len1));
        if(rc < 0)
            return -1;
        pos += rc;
    }

    return pos;
}

cps int
cpc_full_write_3(int fd,
                 const char *buf1, int len1,
                 const char *buf2, int len2,
                 const char *buf3, int len3)
{
    struct iovec iov[3];
    int pos, rc;

    if(len3 == 0) {
        if(len2 == 0)
            return cpc_full_write(fd, buf1, len1);
        else
            return cpc_full_write_2(fd, buf1, len1, buf2, len2);
    }

    iov[0].iov_base = buf1;
    iov[0].iov_len = len1;

    iov[1].iov_base = buf2;
    iov[1].iov_len = len2;

    iov[2].iov_base = buf3;
    iov[2].iov_len = len3;

    pos = 0;
    while(1) {
        rc = writev(fd, iov, 3);
        if(rc < 0) {
            if(errno != EAGAIN)
                return -1;
        } else {
            pos += rc;
            if(pos >= len1)
                break;
        }
        cpc_io_wait(fd, CPC_IO_OUT);
    }

    if(pos < len1 + len2 + len3) {
        cpc_io_wait(fd, CPC_IO_OUT);
        if(pos < len1)
            rc = cpc_full_write_2(fd,
                                  buf2 + (pos - len1), len2 - (pos - len1),
                                  buf3, len3);
        else
            rc = cpc_full_write(fd,
                                buf3 + (pos - len1 - len2),
                                len3 - (pos - len1 - len2));
        if(rc < 0)
            return -1;
        pos += rc;
    }

    return pos;
}

cps int
send_message_2(int fd, int id,
               char *body1, int bodylen1,
               char *body2, int bodylen2)
{
    unsigned char buf[5];
    int rc;

    printf("%3d -> type = %d, length = %d\n", fd, id, bodylen1 + bodylen2 + 1);

    *(uint32_t*)buf = htonl(bodylen1 + bodylen2 + 1);
    buf[4] = id;

    rc = cpc_full_write_3(fd, buf, 5, body1, bodylen1, body2, bodylen2);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_message(int fd, int id, char *body, int bodylen)
{
    unsigned char buf[5];
    int rc;

    return send_message_2(fd, id, body, bodylen, NULL, 0);
}

cps int
send_bitfield(int fd, ht_torrent *t)
{
    int num_chunks = 0, length = 0;
    unsigned char *buf= NULL;
    int rc;

    num_chunks = (t->f_length - 1) / t->p_length + 1;
    length = (num_chunks - 1) / 8 + 1;

    buf = malloc(length);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    memset(buf, 0xFF, length - 1);
    if(num_chunks % 8 == 0)
        buf[length - 1] = 0xFF;
    else
        buf[length - 1] = (0xFF00 >> (num_chunks % 8)) & 0xFF;

    rc = send_message(fd, 5, buf, length);
    if(rc < 0) {
        perror("(send_bitfield)cpc_message");
        return -1;
    }

    return 1;
}

cps int
send_unchoke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 1, NULL, 0);
    if(rc < 0) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_piece(int fd, piece *chunk)
{
    int file, rc;
    unsigned char buf[8];
    void *source;
    ht_torrent *t = requests[fd].t;

    if(!requests[fd].t->map) {
        file = open(t->path, O_RDONLY);
        if(file < 0){
            perror("(send_piece)open");
            return -1;
        }

        requests[fd].t->map = mmap(NULL, t->f_length, PROT_READ,
                                   MAP_PRIVATE, file, 0);
        if(requests[fd].t->map == MAP_FAILED) {
            perror("(send_piece)mmap source");
            return -1;
        }
    }

    source = requests[fd].t->map;
    source += chunk->offset*t->p_length+chunk->begin;

    printf("%3d send chunk: length=%d, offset=%lld\n",
           fd, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)(buf + 0)) = htonl(chunk->offset);
    *((uint32_t *)(buf + 4)) = htonl(chunk->begin);

    rc = send_message_2(fd, 7, buf, 8, source, chunk->length);
    if(rc < 0) {
        perror("(send_piece)write");
        return -1;
    }

    return 0;
}
/* return -1 if sth wrong happend in handshake otherwise return 0 */
cps int
handshake(hashtable *ht , int fd)
{
    int rc = 0;
    const char *protocol = "\023BitTorrent protocol";
    unsigned char hash[20];
    char *res = NULL, *tmp = NULL, t[68];
    ht_torrent *torrent = NULL;

    rc = cpc_full_read(fd, t, 68);
    if(rc < 68) {
        perror("(handshake)cpc_full_read");
        return -1;
    }

    if(memcmp(t, protocol, 20) != 0) {
        fprintf(stderr, "(handshake)bad protocol.\n");
        return -1;
    }

    memcpy(hash, t + 28, 20);

    torrent = ht_get(ht, (unsigned char *)hash);
    if(!torrent) {
        fprintf(stderr, "(handshake) : cannot find the hash in the table\n");
        return -1;
    }

    requests[fd].t = torrent;

    //so all is ok and we can say that all is ok yupiiiii!!!!
    //now lets generate the ACK response
    res = malloc(1 + 19 + 8 + 20 + 20);
    tmp = res;

    tmp[0] = 19;
    tmp ++;

    strncpy(tmp, "BitTorrent protocol", 19);
    tmp += 19;

    memset(tmp, 0, 8);
    tmp += 8;

    memcpy(tmp, torrent->info_hash, 20);
    tmp += 20;

    memcpy(tmp, peer_id, 20);
    tmp += 20;

    rc = cpc_full_write(fd, res, 68);
    if(rc < 68) {
        perror("(handshake)cannot write to fd");
        return -1;
    }

    rc = send_bitfield(fd, torrent);
    if(rc < 0) {
        fprintf(stderr, "couldn't send bitfield\n");
        return -1;
    }

    rc = send_unchoke(fd);
    if(rc < 0) {
        fprintf(stderr, "couldn't send unchoke\n");
        return -1;
    }

    return 0;
}

cps void
stream_writer(int fd)
{
    //while request list non empty, send chunks
    piece *pl;
    int rc;

    while((pl = requests[fd].list)) {
        requests[fd].list = requests[fd].list->next;
        rc = send_piece(fd, pl);
        free(pl);
        if(rc < 0) {
            shutdown(fd, 2);    /* for now */
            break;
        }
        cpc_yield;
    }
    requests[fd].stream_writer = 0;
    return;
}

cps int
stream_reader(int fd)
{
    uint32_t tmp = 0, length = 0;
    char * res = NULL;
    uint32_t begin, index, chunk_len;

    if(cpc_full_read(fd, &tmp, 4) < 4) {
        perror("(stream_read) didn't read 4 bytes");
        return -1;
    }

    length = ntohl(tmp);
    if(length == 0) {
        //keepalive message
        return 0;
    }

    if(length > 128 * 1024) {
        printf("%3d unbelievably long message (%d bytes).\n", fd, length);
        return -1;
    }

    res = malloc(length);
    if(res == NULL)
        return -1;

    if(cpc_full_read(fd, res, length) < 0) {
        perror("(stream_read)cpc_full_read");
        goto fail;
    }

    printf("%3d <- type = %d, length = %d\n", fd, res[0], length);

    if(res[0] != 5 && length > 20) {
        printf("%3d unbelievably long message!\n", fd);
        goto fail;
    }

    switch(res[0]) {
    case 7: case 5: case 0: case 4: case 1: case 2:
        break;

    case 3:
        //not interested
        printf("%3d not interested\n", fd);
        goto fail;

    case 6:                     //request
    case 8:                     //cancel
        if(length < 13)
            goto fail;
        index = ntohl(*((uint32_t *)(res+1)));
        begin = ntohl(*((uint32_t *)(res+5)));
        chunk_len = ntohl(*((uint32_t *)(res+9)));
        printf("%3d %s: index = %u\tbegin = %u\tlength = %u\n",
               fd, res[0] == 6 ? "request" : "cancel",
               index, begin, chunk_len);

        if(res[0] == 6) {
            /* add request in request list */
            requests[fd].list = add_piece(requests[fd].list,
                                          index, begin, chunk_len);
            if(requests[fd].stream_writer == 0) {
                requests[fd].stream_writer = 1;
                cpc_spawn stream_writer(fd);
            }
        } else {
            requests[fd].list = remove_piece(requests[fd].list,
                                             index, begin, chunk_len);
        }
        break;

    default:
        fprintf(stderr , "%3d unexpected message.\n", fd);
        goto fail;
    }
    free(res);
    return 0;

 fail:
    free(res);
    return -1;
}

void free_list_piece(piece * p);

void
free_list_piece(piece * p){
    if(!p)
        return ;
    else{
        free_list_piece(p->next);
        free(p);
        return ;
    }
}


void
free_pieces(int fd)
{
    free_list_piece(requests[fd].list);
    requests[fd].list = NULL;
    requests[fd].t = NULL;
    return ;
}

cps void
client(hashtable *t, int client_fd)
{
    int rc = 0;
    unsigned char buffer[BUF_LEGNTH];

    rc = handshake(t, client_fd);
    if(rc < 0) {
        fprintf(stderr,"(client)broken handshake -- dropping.\n");
        goto done;
    }

    while(1) {
        if(stream_reader(client_fd) < 0)
            break;
    }

 done:
    if(requests[client_fd].stream_writer) {
        shutdown(client_fd, 2);
        /* XXX should use explicit signalling here. */
        do {
            cpc_yield;
        } while(requests[client_fd].stream_writer);
    }
    free_pieces(client_fd);
    close(client_fd);
    return;
}

cps void
listening(hashtable * table)
{
    int socket_fd, client_fd;
    int rc, flags, one = 1;
    socklen_t cli_len;
    struct sockaddr_in serv_addr, cli_addr;

    socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if(socket_fd<0) {
        perror("(listening)socket");
        return;
    }
    rc = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    if(rc) {
        perror("(listening)setsockopt");
        return;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(SERVER_PORT);

    if (bind(socket_fd, (struct sockaddr *) &serv_addr,
             sizeof(serv_addr)) < 0)
        perror("(listening)bind");

    memset(requests, 1024*sizeof(piece), 0);

    rc = listen(socket_fd, 20);
    if(rc < 0) {
        perror("(listening)listen");
        return;
    }

    while(1) {
        cli_len = sizeof(cli_addr);

        cpc_io_wait(socket_fd, CPC_IO_IN);
        client_fd = accept(socket_fd,
                           (struct sockaddr *) &cli_addr,
                           &cli_len);
        if(client_fd<0) {
            perror("(listening)accept");
            return;
        }
        fprintf(stderr,"Got a connection!\n");

        flags = fcntl(client_fd, F_GETFL);
        if(flags < 0) {
            perror("F_GETFL");
            goto fail;
        }
        rc = fcntl(client_fd, F_SETFL, flags|O_NONBLOCK);
        if(rc < 0) {
            perror("F_SETFL");
            goto fail;
        }

        cpc_spawn client(table, client_fd);
        continue;

    fail:
        close(client_fd);
        continue;
    }

    return;
}
