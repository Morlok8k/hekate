/*
Copyright (c) 2009 by Pejman Attar, Yoann Canal, Juliusz Chroboczek and
                      Gabriel Kerneis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <assert.h>

#include <cpc/cpc_lib.h>

#include "util.h"
#include "hashtable.h"
#include "parse.h"
#include "server.h"
#include "torrent.h"
#include "tracker.h"
#include "list.h"
#include "io.h"

#define SERVER_PORT 6969

#define BUF_LENGTH 512
#define DIR_LEN 512
#define FD_MAX 1024

cpc_condvar *choke_cond;

int numpeers = 0;
#define MAX_CONNECTED_PEERS 512

#define MAX_PEER_CREDIT (1024 * 1024)

struct peer peers[FD_MAX];

#define MAX(x, y) ((x) >= (y) ? (x) : (y))
#define MIN(x, y) ((x) >= (y) ? (y) : (x))

cps int
send_message_2(int fd, int id,
               char *body1, int bodylen1, char *body2, int bodylen2)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    printf("%3d -> type = %d, length = %d\n", fd, id, bodylen1 + bodylen2 + 1);

    *(uint32_t*)buf = htonl(bodylen1 + bodylen2 + 1);
    buf[4] = id;

    i = 0;

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen1 > 0) {
        iov[i].iov_base = body1;
        iov[i].iov_len = bodylen1;
        i++;
    }

    if(bodylen2 > 0) {
        iov[i].iov_base = body2;
        iov[i].iov_len = bodylen2;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_message(int fd, int id, char *body, int bodylen)
{
    return send_message_2(fd, id, body, bodylen, NULL, 0);
}

cps int
send_message_h(int fd, char *head, int headlen,
               int id, char *body, int bodylen)
{
    unsigned char buf[5];
    struct iovec iov[3];
    int i, rc;

    printf("%3d -> h=%d, type = %d, length = %d\n",
           fd, headlen, id, bodylen + 1);

    *(uint32_t*)buf = htonl(bodylen + 1);
    buf[4] = id;

    i = 0;

    if(headlen > 0) {
        iov[i].iov_base = head;
        iov[i].iov_len = headlen;
        i++;
    }

    iov[i].iov_base = buf;
    iov[i].iov_len = 5;
    i++;

    if(bodylen > 0) {
        iov[i].iov_base = body;
        iov[i].iov_len = bodylen;
        i++;
    }

    rc = cpc_full_writev(fd, iov, i);
    if(rc < 5)
        return -1;

    return 1;
}

cps int
send_bitfield(int fd, struct torrent *t, char *head, int headlen)
{
    int length = 0;
    unsigned char *buf= NULL;
    int rc;

    length = (t->num_chunks - 1) / 8 + 1;

    buf = malloc(length);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    memset(buf, 0xFF, length - 1);
    if(t->num_chunks % 8 == 0)
        buf[length - 1] = 0xFF;
    else
        buf[length - 1] = (0xFF00 >> (t->num_chunks % 8)) & 0xFF;

    rc = send_message_h(fd, head, headlen, 5, buf, length);
    if(rc < 0) {
        perror("(send_bitfield)cpc_message");
        free(buf);
        return -1;
    }

    free(buf);
    return 1;
}

cps int
send_choke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 0, NULL, 0);
    if(rc < 0) {
        perror("(send_choke)cpc_full_write");
        return -1;
    }
    return 0;
}

cps int
send_unchoke(int fd)
{
    unsigned char buf[5];
    int rc;

    rc = send_message(fd, 1, NULL, 0);
    if(rc < 0) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }
    return 0;
}

void *
map_file(struct torrent *t, int index)
{
    void *map;
    int fd;

    if(t->files[index]->map)
        return 0;

    fd = open(t->files[index]->path, O_RDONLY);
    if(fd < 0)
        return -1;

    map = mmap(NULL, t->files[index]->length,
               PROT_READ, MAP_PRIVATE, fd, 0);
    if(map == MAP_FAILED) {
        int save = errno;
        close(fd);
        errno = save;
        return NULL;
    }
    t->files[index]->map = map;
    close(fd);
    return map;
}

int
find_chunk(struct torrent *t, uint64_t begin, unsigned int length,
           int *first_return, int *last_return,
           unsigned *offset_return, unsigned *last_len_return)
{
    int i, first = -1, last = -1;
    unsigned offset, last_len;
    struct file *f;

    for(i = 0; i < t->num_files; i++) {
        f = t->files[i];
        if(f->offset <= begin) {
            first = i;
        }
        if(f->offset + f->length >= begin + length) {
            last = i;
            break;
        }
    }

    if(first < 0 || last < 0)
        return -1;

    assert(last >= first);
    assert(begin >= t->files[first]->offset);
    assert(begin + length <= t->files[last]->offset + t->files[last]->length);

    offset = begin - t->files[first]->offset;
    /* Chunk beyond last file */
    if(offset > t->files[first]->length)
        return -1;
    if(first == last)
        last_len = length;
    else
        last_len = begin + length - t->files[last]->offset;

    if(first_return)
        *first_return = first;
    if(last_return)
        *last_return = last;
    if(offset_return)
        *offset_return = offset;
    if(last_len_return)
        *last_len_return = last_len;

    return 1;
}

cps int
send_multi_chunk(int fd, struct chunk *chunk,
                 int first, int last, unsigned offset)
{
    unsigned char buf[8];
    unsigned char *body;
    int pos, i, len, rc;
    struct torrent *t = peers[fd].t;

    body = malloc(chunk->length);
    if(!body) {
        perror("(send_multi_chunk)malloc");
        return -1;
    }

    pos = 0;
    for(i = first; i <= last; i++) {
        map_file(t, i);
        if(t->files[i]->map == NULL) {
            perror("map_file");
            goto fail;
        }
        len = (i == first) ? (t->files[i]->length - offset) :
            MIN(chunk->length - pos, t->files[i]->length);
        memcpy(body + pos,
               i == first ? t->files[i]->map + offset : t->files[i]->map,
               len);
        pos += len;
    }

    printf("%3d send chunk: length=%d, offset=%lld\n",
           fd, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)(buf + 0)) = htonl(chunk->offset);
    *((uint32_t *)(buf + 4)) = htonl(chunk->begin);

    /* pos may be smaller than chunk->length, if the chunk extended beyond
       the end of the torrent. */
    rc = send_message_2(fd, 7, buf, 8, body, pos);
    if(rc < 0) {
        perror("(send_chunk)write");
        goto fail;
    }

    peers[fd].credit -= chunk->length;
    assert(peers[fd].credit >= 0 && peers[fd].credit < MAX_PEER_CREDIT);

    free(body);
    return 0;

 fail:
    free(body);
    return -1;
}

cps int
send_chunk(int fd, struct chunk *chunk)
{
    int file, i, rc;
    unsigned char buf[8];
    void *source;
    struct torrent *t = peers[fd].t;
    int first, last;
    unsigned offset;
    struct file *f;

    if(chunk->length > MAX_PEER_CREDIT) {
        fprintf(stderr, "Chunk larger than max credit!\n");
        return -1;
    }

    if(peers[fd].credit < chunk->length) {
        if(numpeers <= 1 + MAX_CONNECTED_PEERS / 10) {
            /* We've got very few peers, replenish. */
            printf("%3d replenish\n", fd);
            peers[fd].credit = MAX_PEER_CREDIT;
        } else if(numpeers < MAX_CONNECTED_PEERS) {
            /* Our queue is not full yet, choke this client for a small time. */
            printf("%3d temporary choke\n", fd);
            rc = send_choke(fd);
            if(rc < 0)
                return -1;
            free_chunks(fd);
            cpc_signal(choke_cond);
            cpc_wait(choke_cond);
            rc = send_unchoke(fd);
            if(rc < 0)
                return -1;
            peers[fd].credit = MAX_PEER_CREDIT;
        } else {
            /* Drop this client connection, so that others get a chance. */
            printf("%3d dropping\n", fd);
            return -1;
        }
    }

    rc = find_chunk(t, chunk->offset * t->p_length + chunk->begin,
                    chunk->length, &first, &last, &offset, NULL);
    if(rc < 0) {
        fprintf(stderr, "Couldn't find chunk.\n");
        return -1;
    }

    if(first != last) {
        /* For simplicity, we always use a native thread for data that's at
           a chunk border. */
        cpc_detached {
            return send_multi_chunk(fd, chunk, first, last, offset);
        }
    }

    map_file(peers[fd].t, first);
    if(peers[fd].t->files[first]->map == NULL) {
        perror("map_file");
        return -1;
    }

    source = peers[fd].t->files[first]->map + offset;

    printf("%3d send chunk: length=%d, offset=%lld\n",
           fd, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    *((uint32_t *)(buf + 0)) = htonl(chunk->offset);
    *((uint32_t *)(buf + 4)) = htonl(chunk->begin);

    if(!incore(source, chunk->length)) {
        /* Since we prefetch when we first get a request, this chunk should
           arrive into core soon.  Yield in order to give it a chance. */
        cpc_yield;
        if(!incore(source, chunk->length)) {
            /* Still not in core.  Use a native thread to avoid blocking. */
            cpc_detached {
                rc = send_message_2(fd, 7, buf, 8, source, chunk->length);
                if(rc < 0) {
                    perror("(send_chunk)write");
                    return -1;
                }
            }
            goto done;
        }
    }

    rc = send_message_2(fd, 7, buf, 8, source, chunk->length);
    if(rc < 0) {
        perror("(send_chunk)write");
        return -1;
    }

 done:
    peers[fd].credit -= chunk->length;
    assert(peers[fd].credit >= 0 && peers[fd].credit < MAX_PEER_CREDIT);

    return 0;
}
/* return -1 if sth wrong happend in handshake otherwise return 0 */
cps int
handshake(hashtable *ht , int fd)
{
    int rc, numread;
    const char *protocol = "\023BitTorrent protocol";
    char *res = NULL, *tmp = NULL, t[68];
    struct torrent *torrent = NULL;

    /* The wikified spec implies that we must send our handshake as soon as
       we get the info_hash, or risk a deadlock when the tracker performs
       its ``NAT check''.  No, I don't claim to understand it either. */

    numread = cpc_partial_read(fd, t, 48, 68);
    if(numread < 48) {
        perror("(handshake)cpc_full_read");
        return -1;
    }

    if(memcmp(t, protocol, 20) != 0) {
        fprintf(stderr, "(handshake)bad protocol.\n");
        return -1;
    }

    torrent = ht_get(ht, t + 28);
    if(!torrent) {
        fprintf(stderr, "(handshake): cannot find hash ");
        for(int i = 0;i<20;i++)
            fprintf(stderr, "%.2x", (unsigned char)*(t + 28 + i));
        fprintf(stderr, "\n");
        return -1;
    }

    printf("%3d Torrent requested: ", fd);
    for(int i = 0;i<20;i++)
        printf("%.2x", (unsigned char)*(t + 28 + i));
    printf("\n");

    peers[fd].t = torrent;
    peers[fd].credit = MAX_PEER_CREDIT;

    //so all is ok and we can say that all is ok yupiiiii!!!!
    //now lets generate the ACK response
    res = malloc(1 + 19 + 8 + 20 + 20);
    tmp = res;

    tmp[0] = 19;
    tmp ++;

    strncpy(tmp, "BitTorrent protocol", 19);
    tmp += 19;

    memset(tmp, 0, 8);
    tmp += 8;

    memcpy(tmp, torrent->info_hash, 20);
    tmp += 20;

    memcpy(tmp, peer_id, 20);
    tmp += 20;

    rc = send_bitfield(fd, torrent, res, 68);
    if(rc < 0)
        return -1;

    if(numread < 68) {
        /* Read the rest of the client handshake. */
        rc = cpc_full_read(fd, t + numread, 68 - numread);
        if(rc < 68 - numread)
            return -1;
    }

    return 0;
}

cps void
stream_writer(int fd)
{
    //while request list non empty, send chunks
    struct chunk *chunk;
    int rc;

    while(1) {
        if(!peers[fd].list)
            cpc_wait(peers[fd].sw_cond);

        chunk = peers[fd].list;

        peers[fd].list = peers[fd].list->next;
        rc = send_chunk(fd, chunk);
        if(rc < 0)
            goto done;
        free(chunk);
        cpc_yield;
    }

 done:
    shutdown(fd, 2);
    cpc_barrier_await(peers[fd].barrier);
}

cps int
stream_reader(int fd)
{
    uint32_t length = 0;
    unsigned char *buff = NULL;
    uint32_t begin, index, chunk_len;
    int start = 0, end = 0, buf_len = 0;

    buff = malloc(BUF_LENGTH);
    if(!buff)
        return -1;

    while(1){

        buf_len = end - start;
        assert(buf_len >= 0);
        if(buf_len < 4) {
            if(start != end)
                memmove(buff, buff + start, buf_len);

            end = cpc_partial_read(fd, buff + buf_len, 4 - buf_len, BUF_LENGTH - buf_len);
            if(end < 4)
                goto fail;
            end += buf_len;
            start = 0;
        }

        length = ntohl(*(uint32_t *)(buff + start));
        assert(length >= 0);

        start += 4;

        if(length == 0) {
            //keepalive message
            continue;
        }

        if(length > 128 * 1024) {
            printf("%3d unbelievably long message (%d bytes).\n", fd, length);
            goto fail;
        }

        buf_len = end - start;
        assert(buf_len >= 0);
        if(buf_len < length){
            if(start != end)
                memmove(buff, buff + start, buf_len);

            end = cpc_partial_read(fd, buff + buf_len, length - buf_len, BUF_LENGTH - buf_len);
            /* XXX Do not remove the first comparison, since len is
             * implicitely cast to an UNSIGNED int in the second one. */
            if(end < 0 || end < length)
                goto fail;
            assert(end > 0);
            end += buf_len;
            start = 0;
        }

        printf("%3d <- type = %d, length = %d\n", fd, buff[start], length);

        if(buff[start] != 5 && length > 20) {
            printf("%3d unbelievably long message!\n", fd);
            goto fail;
        }

        switch(buff[start]) {
        case 7: case 5: case 0: case 1: case 2: case 4:
            break;

        case 3:                     //not interested
            printf("%3d not interested\n", fd);
            goto fail;

        case 6:                     //request
        case 8:                     //cancel
            if(length < 13) {
                fprintf(stderr, "Too short message.\n");
                goto fail;
            }
            index = ntohl(*((uint32_t *)(&(buff[start])+1)));
            begin = ntohl(*((uint32_t *)(&(buff[start])+5)));
            chunk_len = ntohl(*((uint32_t *)(&(buff[start])+9)));
            if(chunk_len == 0){
                fprintf(stderr, "Request length is zero.\n");
                goto fail;
            }
            printf("%3d %s: index = %u\tbegin = %u\tlength = %u\n",
                   fd, buff[start] == 6 ? "request" : "cancel",
                   index, begin, chunk_len);
            if(chunk_len > 1024 * 1024) {
                fprintf(stderr, "Unbelievably large chunk size requested.\n");
                goto fail;
            }

            if((int)buff[start] == 6) {
                int rc, i, first, last;
                unsigned offset, last_len;
                rc = find_chunk(peers[fd].t,
                                index * peers[fd].t->p_length + begin,
                                chunk_len,
                                &first, &last, &offset, &last_len);
                if(rc < 0) {
                    fprintf(stderr, "find_chunk fail.\n");
                    goto fail;
                }
                peers[fd].list = add_chunk(peers[fd].list,
                                           index, begin, chunk_len);
                for(i = first; i <= last; i++) {
                    if(peers[fd].t->files[i]->map)
                        prefetch(peers[fd].t->files[i]->map +
                                 (i == first ? offset : 0),
                                 i == last ?
                                 last_len : peers[fd].t->files[i]->length);
                }
                cpc_signal(peers[fd].sw_cond);
            } else {
                peers[fd].list = remove_chunk(peers[fd].list,
                                              index, begin, chunk_len);
            }
            break;

        default:
            fprintf(stderr , "%3d unexpected message.\n", fd);
            goto fail;
        }
        start += length;
    }
 fail:
    free(buff);
    return -1;
}

void
free_chunk_list(struct chunk* c) {
    struct chunk *next;
    while(c) {
        next = c->next;
        free(c);
        c = next;
    }
}


void
free_chunks(int fd)
{
    free_chunk_list(peers[fd].list);
    peers[fd].list = NULL;
    return ;
}

cps void
client(hashtable *t, int client_fd)
{
    int rc = 0;
    unsigned char buffer[BUF_LENGTH];

    peers[client_fd].sw_cond = cpc_condvar_get();
    peers[client_fd].barrier = cpc_barrier_get(2);

    cpc_spawn stream_writer(client_fd);

    rc = handshake(t, client_fd);
    if(rc < 0) {
        fprintf(stderr,"(client)broken handshake -- dropping.\n");
        goto done;
    }

    if(numpeers > MAX_CONNECTED_PEERS / 10)
        cpc_wait(choke_cond);

    rc = send_unchoke(client_fd);
    if(rc < 0) {
        fprintf(stderr, "couldn't send unchoke\n");
        return;
    }

    rc = stream_reader(client_fd);

 done:
    shutdown(client_fd, 2);
    cpc_signal(peers[client_fd].sw_cond);
    cpc_barrier_await(peers[client_fd].barrier);

    free_chunks(client_fd);
    cpc_condvar_release(peers[client_fd].sw_cond);

    numpeers--;
    cpc_signal(choke_cond);

    close(client_fd);
    return;
}

cps void
listening(hashtable * table)
{
    int socket_fd, client_fd;
    int rc, flags, one = 1, zero = 0;
    socklen_t cli_len;
    struct sockaddr_in6 serv_addr, cli_addr;

    socket_fd = socket(AF_INET6, SOCK_STREAM, 0);
    if(socket_fd<0) {
        perror("(listening)socket");
        return;
    }

    rc = setsockopt(socket_fd, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(zero));
    if(rc) {
        perror("(listening)setsockopt(IPV6_V6ONLY)");
        return;
    }

    rc = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
    if(rc) {
        perror("(listening)setsockopt");
        return;
    }

    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin6_family = AF_INET6;
    serv_addr.sin6_port = htons(SERVER_PORT);

    if (bind(socket_fd, (struct sockaddr *) &serv_addr,
             sizeof(serv_addr)) < 0)
        perror("(listening)bind");

    memset(peers, FD_MAX*sizeof(struct peer), 0);

    rc = listen(socket_fd, 20);
    if(rc < 0) {
        perror("(listening)listen");
        return;
    }

    choke_cond = cpc_condvar_get();

    while(1) {
        cpc_io_wait(socket_fd, CPC_IO_IN);

        cli_len = sizeof(cli_addr);
        client_fd = accept(socket_fd,
                           (struct sockaddr *)&cli_addr,
                           &cli_len);
        if(client_fd<0) {
            perror("(listening)accept");
            cpc_sleep(1);
            continue;
        }
        fprintf(stderr,"Got a connection!\n");
        assert(!peers[client_fd].t);

        /* XXX */
        if(client_fd > FD_MAX)
            goto fail;

        assert(numpeers >= 0 && numpeers <= MAX_CONNECTED_PEERS);
        if(numpeers >= MAX_CONNECTED_PEERS) {
            fprintf(stderr, "Dropping peer connection.\n");
            goto fail;
        }

        flags = fcntl(client_fd, F_GETFL);
        if(flags < 0) {
            perror("F_GETFL");
            goto fail;
        }
        rc = fcntl(client_fd, F_SETFL, flags|O_NONBLOCK);
        if(rc < 0) {
            perror("F_SETFL");
            goto fail;
        }

        numpeers++;
        cpc_spawn client(table, client_fd);
        continue;

    fail:
        close(client_fd);
        cpc_condvar_release(choke_cond);
        continue;
    }

    return;
}
